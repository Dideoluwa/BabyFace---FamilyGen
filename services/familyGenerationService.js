const { GoogleGenAI } = require("@google/genai");
const sharp = require("sharp");
const fs = require("fs");
const path = require("path");

class FamilyGenerationService {
  constructor() {
    this.ai = new GoogleGenAI({
      apiKey: process.env.GEMINI_API_KEY,
    });
    this.uploadDir = process.env.UPLOAD_PATH || "./uploads";

    // Ensure upload directory exists
    if (!fs.existsSync(this.uploadDir)) {
      fs.mkdirSync(this.uploadDir, { recursive: true });
    }
  }

  /**
   * Generate family picture with children
   * @param {Buffer} parent1Buffer - First parent image buffer
   * @param {Buffer} parent2Buffer - Second parent image buffer
   * @param {string} parent1Filename - First parent filename
   * @param {string} parent2Filename - Second parent filename
   * @param {Object} options - Family generation options
   * @returns {Promise<Object>} - Generated family image data and metadata
   */
  async generateFamilyPicture(parent1Buffer, parent2Buffer, parent1Filename, parent2Filename, options = {}) {
    try {
      const {
        numberOfChildren = 2,
        ageGap = 2,
        youngestAge = 4,
        quality = 95,
        format = 'jpeg',
        enhanceQuality = true
      } = options;

      // Process both input images with high quality settings
      const processedParent1 = await this.processInputImage(parent1Buffer, {
        maxWidth: 2048,
        maxHeight: 2048,
        quality: quality,
        format: format,
        enhanceQuality: enhanceQuality
      });

      const processedParent2 = await this.processInputImage(parent2Buffer, {
        maxWidth: 2048,
        maxHeight: 2048,
        quality: quality,
        format: format,
        enhanceQuality: enhanceQuality
      });

      // Convert images to base64
      const parent1Base64 = processedParent1.toString("base64");
      const parent2Base64 = processedParent2.toString("base64");

      // Create the family generation prompt
      const prompt = this.createFamilyPrompt(numberOfChildren, ageGap, youngestAge);

      // Generate the family image using Gemini 2.5 Flash Image Preview
      const response = await this.ai.models.generateContent({
        model: "gemini-2.5-flash-image-preview",
        contents: [
          {
            text: prompt,
          },
          {
            inlineData: {
              mimeType: "image/jpeg",
              data: parent1Base64, // First parent
            },
          },
          {
            inlineData: {
              mimeType: "image/jpeg", 
              data: parent2Base64, // Second parent
            },
          },
        ],
      });

      // Extract the generated image
      const generatedImageData = this.extractGeneratedImage(response);

      if (!generatedImageData) {
        throw new Error("No family image was generated by Gemini");
      }

      // Save the generated image
      const outputFilename = this.generateFamilyFilename(parent1Filename, parent2Filename);
      const outputPath = path.join(this.uploadDir, outputFilename);

      await fs.promises.writeFile(outputPath, generatedImageData);

      const result = {
        success: true,
        parent1Filename: parent1Filename,
        parent2Filename: parent2Filename,
        generatedFilename: outputFilename,
        outputPath: outputPath,
        imageData: generatedImageData,
        familySpecs: {
          numberOfChildren,
          ageGap,
          youngestAge,
          childrenAges: this.calculateChildrenAges(numberOfChildren, ageGap, youngestAge)
        },
        metadata: {
          model: "gemini-2.5-flash-image-preview",
          timestamp: new Date().toISOString(),
          transformation: "family-generation",
          parents: 2,
          children: numberOfChildren
        },
      };

      console.log("Generated family result:", {
        success: result.success,
        parent1Filename: result.parent1Filename,
        parent2Filename: result.parent2Filename,
        generatedFilename: result.generatedFilename,
        outputPath: result.outputPath,
        imageDataSize: result.imageData ? result.imageData.length : 0,
        familySpecs: result.familySpecs,
        metadata: result.metadata,
      });

      return result;
    } catch (error) {
      console.error("Family generation error:", error);
      throw new Error(`Family generation failed: ${error.message}`);
    }
  }

  /**
   * Process input image for optimal results
   * @param {Buffer} imageBuffer - Input image buffer
   * @param {Object} options - Processing options
   * @returns {Promise<Buffer>} - Processed image buffer
   */
  async processInputImage(imageBuffer, options = {}) {
    try {
      const {
        maxWidth = 2048,
        maxHeight = 2048,
        quality = 95,
        format = 'jpeg',
        enhanceQuality = true
      } = options;

      let sharpInstance = sharp(imageBuffer);

      if (enhanceQuality) {
        sharpInstance = sharpInstance
          .sharpen({ sigma: 1.0, m1: 0.5, m2: 3.0, x1: 2, y2: 10 })
          .normalize()
          .modulate({ brightness: 1.05, saturation: 1.1 });
      }

      sharpInstance = sharpInstance.resize(maxWidth, maxHeight, {
        fit: "inside",
        withoutEnlargement: false,
        kernel: sharp.kernel.lanczos3
      });

      if (format === 'jpeg') {
        sharpInstance = sharpInstance.jpeg({
          quality: quality,
          progressive: true,
          mozjpeg: true,
          chromaSubsampling: '4:4:4'
        });
      } else if (format === 'png') {
        sharpInstance = sharpInstance.png({
          quality: quality,
          compressionLevel: 6,
          progressive: true
        });
      } else if (format === 'webp') {
        sharpInstance = sharpInstance.webp({
          quality: quality,
          lossless: false,
          nearLossless: true
        });
      }

      const processedBuffer = await sharpInstance.toBuffer();
      return processedBuffer;
    } catch (error) {
      console.error("Image processing error:", error);
      throw new Error("Failed to process input image");
    }
  }


  createFamilyPrompt(numberOfChildren, ageGap, youngestAge) {
    const childrenAges = this.calculateChildrenAges(numberOfChildren, ageGap, youngestAge);
    const ageDescriptions = childrenAges.map(age => `${age}-year-old`).join(', ');
    
    return `Create a beautiful family portrait showing the two parents with their ${numberOfChildren} children.

CRITICAL REQUIREMENTS:
1. PARENTS: Use the two provided images as the parents. Keep their faces, features, and characteristics exactly as they are.
2. PRESERVE RACE AND ETHNICITY: Maintain the exact same racial and ethnic characteristics for all family members. Children should inherit appropriate features from both parents.
3. CHILDREN GENERATION: Create ${numberOfChildren} realistic children with ages: ${ageDescriptions}.
4. CHILDREN FEATURES: Each child should show clear resemblance to both parents:
   - Mix facial features from both parents
   - Inherit appropriate skin tone and hair characteristics
   - Show family resemblance while being unique individuals
5. RANDOM GENDER ASSIGNMENT: Randomly assign genders to the children (mix of boys and girls).
6. FAMILY POSING: Arrange the family in a natural, loving pose:
   - Parents can be standing or sitting
   - Children positioned naturally around parents
   - Family members touching or close to each other
   - Warm, happy expressions on all faces
7. PROFESSIONAL SETTING: Place the family in a beautiful setting such as:
   - Professional photography studio
   - Elegant living room
   - Beautiful outdoor garden
   - Modern family home interior
8. CLOTHING: Dress everyone in coordinated, family-appropriate clothing:
   - Parents in smart casual or formal wear
   - Children in age-appropriate, matching family outfits
   - Color coordination that looks natural
9. ULTRA-HIGH QUALITY: Generate an ULTRA-HIGH-RESOLUTION image with:
   - Crystal clear details and sharp focus
   - Professional lighting with soft shadows
   - Perfect color accuracy and contrast
   - Smooth gradients and natural textures
   - Studio-quality photography appearance
10. NATURAL INTEGRATION: Make the family look like they belong together:
    - Consistent lighting across all family members
    - Natural skin tones and realistic features
    - Proper proportions and realistic interactions
    - Cohesive family atmosphere

FAMILY SPECIFICATIONS:
- Parents: 2 adults (from provided images)
- Children: ${numberOfChildren} children (ages: ${childrenAges.join(', ')})
- Gender distribution: Random mix of boys and girls
- Family resemblance: Clear inheritance from both parents
- Setting: Professional family photography environment
- Quality: Ultra-high resolution, photorealistic

The result should be a beautiful, professional family portrait showing the parents with their children, all looking like a real family with clear genetic resemblance and natural interactions.`;
  }

  /**
   * Calculate children ages based on parameters
   * @param {number} numberOfChildren - Number of children
   * @param {number} ageGap - Age gap between children
   * @param {number} youngestAge - Age of youngest child
   * @returns {Array} - Array of children ages (oldest to youngest)
   */
  calculateChildrenAges(numberOfChildren, ageGap, youngestAge) {
    const ages = [];
    for (let i = 0; i < numberOfChildren; i++) {
      // Calculate age: youngest + (index * ageGap)
      // This ensures proper age progression
      ages.push(youngestAge + (i * ageGap));
    }
    // Return ages from oldest to youngest for display
    return ages.sort((a, b) => b - a);
  }

  /**
   * Extract generated image from Gemini response
   * @param {Object} response - Gemini API response
   * @returns {Buffer|null} - Generated image buffer or null
   */
  extractGeneratedImage(response) {
    try {
      if (
        !response.candidates ||
        !response.candidates[0] ||
        !response.candidates[0].content
      ) {
        return null;
      }

      const parts = response.candidates[0].content.parts;

      for (const part of parts) {
        if (part.inlineData && part.inlineData.data) {
          return Buffer.from(part.inlineData.data, "base64");
        }
      }

      return null;
    } catch (error) {
      console.error("Error extracting generated image:", error);
      return null;
    }
  }

  /**
   * Generate output filename for family image
   * @param {string} parent1Filename - First parent filename
   * @param {string} parent2Filename - Second parent filename
   * @returns {string} - Generated filename
   */
  generateFamilyFilename(parent1Filename, parent2Filename) {
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(2, 8);
    const extension = "jpg";
    const parent1Name = path.parse(parent1Filename).name.substring(0, 3);
    const parent2Name = path.parse(parent2Filename).name.substring(0, 3);
    return `family-${parent1Name}-${parent2Name}-${timestamp}-${randomId}.${extension}`;
  }

  /**
   * Clean up old files (optional utility method)
   * @param {number} maxAgeHours - Maximum age in hours
   */
  async cleanupOldFiles(maxAgeHours = 24) {
    try {
      const files = await fs.promises.readdir(this.uploadDir);
      const now = Date.now();
      const maxAge = maxAgeHours * 60 * 60 * 1000; // Convert to milliseconds

      for (const file of files) {
        const filePath = path.join(this.uploadDir, file);
        const stats = await fs.promises.stat(filePath);

        if (now - stats.mtime.getTime() > maxAge) {
          await fs.promises.unlink(filePath);
          console.log(`Cleaned up old file: ${file}`);
        }
      }
    } catch (error) {
      console.error("Error cleaning up files:", error);
    }
  }
}

module.exports = FamilyGenerationService;
