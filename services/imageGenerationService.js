const { GoogleGenAI } = require("@google/genai");
const sharp = require("sharp");
const fs = require("fs");
const path = require("path");

class ImageGenerationService {
  constructor() {
    this.ai = new GoogleGenAI({
      apiKey: process.env.GEMINI_API_KEY,
    });
    this.uploadDir = process.env.UPLOAD_PATH || "./uploads";

    if (!fs.existsSync(this.uploadDir)) {
      fs.mkdirSync(this.uploadDir, { recursive: true });
    }
  }

  async generateBabyFaceImage(imageBuffer, filename, options = {}) {
    try {
      const processedImage = await this.processInputImage(imageBuffer, {
        maxWidth: options.maxWidth || 2048,
        maxHeight: options.maxHeight || 2048,
        quality: options.quality || 95,
        format: options.format || "jpeg",
        enhanceQuality: options.enhanceQuality !== false,
      });

      const base64Image = processedImage.toString("base64");

      const prompt = this.createTransformationPrompt();

      const response = await this.ai.models.generateContent({
        model: "gemini-2.5-flash-image-preview",
        contents: [
          {
            text: prompt,
          },
          {
            inlineData: {
              mimeType: "image/jpeg",
              data: base64Image,
            },
          },
        ],
      });

      const generatedImageData = this.extractGeneratedImage(response);

      if (!generatedImageData) {
        throw new Error("No image was generated by Gemini");
      }

      // const outputFilename = this.generateOutputFilename(filename);
      // const outputPath = path.join(this.uploadDir, outputFilename);

      // await fs.promises.writeFile(outputPath, generatedImageData);

      const result = {
        success: true,

        imageData: generatedImageData,
        base64Data: generatedImageData.toString("base64"),
      };

      console.log("Generated image result:", {
        success: result.success,
        // base64Data: result.base64Data,
        imageDataSize: result.imageData ? result.imageData.length : 0,
        // metadata: result.metadata,
      });
      return result;
    } catch (error) {
      console.error("Image generation error:", error);
      throw new Error(`Image generation failed: ${error.message}`);
    }
  }

  async processInputImage(imageBuffer, options = {}) {
    try {
      const {
        maxWidth = 2048,
        maxHeight = 2048,
        quality = 95,
        format = "jpeg",
        enhanceQuality = true,
      } = options;

      let sharpInstance = sharp(imageBuffer);

      if (enhanceQuality) {
        sharpInstance = sharpInstance
          .sharpen({ sigma: 1.0, m1: 0.5, m2: 3.0, x1: 2, y2: 10 })
          .normalize()
          .modulate({ brightness: 1.05, saturation: 1.1 });
      }

      sharpInstance = sharpInstance.resize(maxWidth, maxHeight, {
        fit: "inside",
        withoutEnlargement: false,
        kernel: sharp.kernel.lanczos3,
      });

      if (format === "jpeg") {
        sharpInstance = sharpInstance.jpeg({
          quality: quality,
          progressive: true,
          mozjpeg: true,
          chromaSubsampling: "4:4:4",
        });
      } else if (format === "png") {
        sharpInstance = sharpInstance.png({
          quality: quality,
          compressionLevel: 6,
          progressive: true,
        });
      } else if (format === "webp") {
        sharpInstance = sharpInstance.webp({
          quality: quality,
          lossless: false,
          nearLossless: true,
        });
      }

      const processedBuffer = await sharpInstance.toBuffer();
      return processedBuffer;
    } catch (error) {
      console.error("Image processing error:", error);
      throw new Error("Failed to process input image");
    }
  }

  createTransformationPrompt() {
    return `Transform this image by taking the adult person's face and placing it on a baby's body in high-resolution.
CRITICAL REQUIREMENTS:
PRESERVE RACE AND ETHNICITY: Maintain the exact same racial and ethnic characteristics of the original face. Do not change skin tone, eye shape, hair texture, or any racial features.
FACE PRESERVATION: Keep the adult facial features, expressions, and characteristics EXACTLY as they are - do not make the face look younger or childlike. This is an adult face on a baby body.
HEAD PROPORTIONING: Scale the adult head to fit proportionally on the baby's body while maintaining all adult facial features and characteristics.
REMOVE HEADGEAR: If the person is wearing any cap, hat, helmet, headband, or any other headgear, REMOVE IT COMPLETELY and show the person's natural hair and head shape while keeping all facial features exactly as they are.
BABY BODY: Create a realistic baby's body (small, chubby, infant proportions) that matches the preserved racial characteristics and skin tone.
BABY SETTING: Place the baby in an appropriate baby environment such as:
   - A baby stroller/trolley
   - A crib or nursery
   - Being held in someone's arms
   - On a baby blanket or play mat
   - In a high chair
   - Any other typical baby setting
BABY CLOTHING: Dress the baby in appropriate infant clothing like onesies, baby outfits, or swaddling.
NATURAL INTEGRATION: Make the transformation look natural and seamless, ensuring the adult head blends well with the baby body despite the contrast.
HIGH QUALITY: Generate a photorealistic, high-resolution image with proper lighting and shadows.
CONSISTENT STYLE: Maintain the same artistic style and quality as the original image.
The result should show how this adult would look if they had their current adult face on a baby's body in a typical baby setting.`;
  }

  extractGeneratedImage(response) {
    try {
      if (
        !response.candidates ||
        !response.candidates[0] ||
        !response.candidates[0].content
      ) {
        return null;
      }

      const parts = response.candidates[0].content.parts;

      for (const part of parts) {
        if (part.inlineData && part.inlineData.data) {
          return Buffer.from(part.inlineData.data, "base64");
        }
      }

      return null;
    } catch (error) {
      console.error("Error extracting generated image:", error);
      return null;
    }
  }

  generateOutputFilename(originalFilename) {
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(2, 8);
    const extension = "jpg";
    return `baby-face-${timestamp}-${randomId}.${extension}`;
  }

  async cleanupOldFiles(maxAgeHours = 24) {
    try {
      const files = await fs.promises.readdir(this.uploadDir);
      const now = Date.now();
      const maxAge = maxAgeHours * 60 * 60 * 1000;

      for (const file of files) {
        const filePath = path.join(this.uploadDir, file);
        const stats = await fs.promises.stat(filePath);

        if (now - stats.mtime.getTime() > maxAge) {
          await fs.promises.unlink(filePath);
          console.log(`Cleaned up old file: ${file}`);
        }
      }
    } catch (error) {
      console.error("Error cleaning up files:", error);
    }
  }
}

module.exports = ImageGenerationService;
