const { GoogleGenAI } = require("@google/genai");
const sharp = require("sharp");
const fs = require("fs");
const path = require("path");

class ImageGenerationService {
  constructor() {
    this.ai = new GoogleGenAI({
      apiKey: process.env.GEMINI_API_KEY,
    });
    this.uploadDir = process.env.UPLOAD_PATH || "./uploads";

    if (!fs.existsSync(this.uploadDir)) {
      fs.mkdirSync(this.uploadDir, { recursive: true });
    }
  }

  async generateBabyFaceImage(imageBuffer, filename, options = {}) {
    try {
      const processedImage = await this.processInputImage(imageBuffer, {
        maxWidth: options.maxWidth || 2048,
        maxHeight: options.maxHeight || 2048,
        quality: options.quality || 95,
        format: options.format || 'jpeg',
        enhanceQuality: options.enhanceQuality !== false
      });

      const base64Image = processedImage.toString("base64");

      const prompt = this.createTransformationPrompt();

      const response = await this.ai.models.generateContent({
        model: "gemini-2.5-flash-image-preview",
        contents: [
          {
            text: prompt,
          },
          {
            inlineData: {
              mimeType: "image/jpeg",
              data: base64Image,
            },
          },
        ],
      });

      const generatedImageData = this.extractGeneratedImage(response);

      if (!generatedImageData) {
        throw new Error("No image was generated by Gemini");
      }

      const outputFilename = this.generateOutputFilename(filename);
      const outputPath = path.join(this.uploadDir, outputFilename);

      await fs.promises.writeFile(outputPath, generatedImageData);

      const result = {
        success: true,
        originalFilename: filename,
        generatedFilename: outputFilename,
        outputPath: outputPath,
        imageData: generatedImageData,
        metadata: {
          model: "gemini-2.5-flash-image-preview",
          timestamp: new Date().toISOString(),
          transformation: "adult-face-to-baby-body",
        },
      };

      console.log("Generated image result:", {
        success: result.success,
        originalFilename: result.originalFilename,
        generatedFilename: result.generatedFilename,
        outputPath: result.outputPath,
        imageDataSize: result.imageData ? result.imageData.length : 0,
        metadata: result.metadata,
      });
      return result;
    } catch (error) {
      console.error("Image generation error:", error);
      throw new Error(`Image generation failed: ${error.message}`);
    }
  }

  async processInputImage(imageBuffer, options = {}) {
    try {
      const {
        maxWidth = 2048,
        maxHeight = 2048,
        quality = 95,
        format = 'jpeg',
        enhanceQuality = true
      } = options;

      let sharpInstance = sharp(imageBuffer);

      if (enhanceQuality) {
        sharpInstance = sharpInstance
          .sharpen({ sigma: 1.0, m1: 0.5, m2: 3.0, x1: 2, y2: 10 })
          .normalize()
          .modulate({ brightness: 1.05, saturation: 1.1 });
      }

      sharpInstance = sharpInstance.resize(maxWidth, maxHeight, {
        fit: "inside",
        withoutEnlargement: false,
        kernel: sharp.kernel.lanczos3
      });

      if (format === 'jpeg') {
        sharpInstance = sharpInstance.jpeg({
          quality: quality,
          progressive: true,
          mozjpeg: true, 
          chromaSubsampling: '4:4:4' 
        });
      } else if (format === 'png') {
        sharpInstance = sharpInstance.png({
          quality: quality,
          compressionLevel: 6,
          progressive: true
        });
      } else if (format === 'webp') {
        sharpInstance = sharpInstance.webp({
          quality: quality,
          lossless: false,
          nearLossless: true
        });
      }

      const processedBuffer = await sharpInstance.toBuffer();
      return processedBuffer;
    } catch (error) {
      console.error("Image processing error:", error);
      throw new Error("Failed to process input image");
    }
  }

  createTransformationPrompt() {
    return `Transform this image by taking the adult person's face and placing it on a baby's body in ULTRA-HIGH RESOLUTION and PHOTOREALISTIC QUALITY.

CRITICAL REQUIREMENTS:
1. PRESERVE ADULT FACE: Keep the adult face EXACTLY as it is - do not make it look younger or change any facial features. The adult face should remain completely unchanged.
2. PRESERVE RACE AND ETHNICITY: Maintain the exact same racial and ethnic characteristics of the original face. Do not change skin tone, eye shape, hair texture, or any racial features.
3. BABY BODY: Create a realistic baby's body (small, chubby, proportioned like an infant) that matches the preserved racial characteristics and skin tone of the face.
3. REMOVE HEADGEAR: If the person is wearing any cap, hat, helmet, headband, or any other headgear, REMOVE IT COMPLETELY and show the person's natural hair and head shape.
4. BABY SETTING: Place the baby in an appropriate baby environment such as:
   - A baby stroller/trolley
   - A crib or nursery
   - Being held in someone's arms
   - On a baby blanket or play mat
   - In a high chair
   - Any other typical baby setting
5. BABY CLOTHING: Dress the baby in appropriate infant clothing like onesies, baby outfits, or swaddling.
6. NATURAL INTEGRATION: Make the transformation look natural and seamless, ensuring the adult face fits proportionally on the baby body.
7. ULTRA-HIGH QUALITY: Generate an ULTRA-HIGH-RESOLUTION image with:
   - Smooth gradients and natural textures
8. CONSISTENT STYLE: Maintain the same artistic style and quality as the original image.

QUALITY SPECIFICATIONS:
- Resolution: Maximum possible resolution
- Colors: Accurate, vibrant, natural colors
- Textures: Smooth, realistic skin and fabric textures

The result should show the person's unchanged adult face on a baby's body in a typical baby environment, creating a humorous but realistic composite image.`;
  }

  extractGeneratedImage(response) {
    try {
      if (
        !response.candidates ||
        !response.candidates[0] ||
        !response.candidates[0].content
      ) {
        return null;
      }

      const parts = response.candidates[0].content.parts;

      for (const part of parts) {
        if (part.inlineData && part.inlineData.data) {
          return Buffer.from(part.inlineData.data, "base64");
        }
      }

      return null;
    } catch (error) {
      console.error("Error extracting generated image:", error);
      return null;
    }
  }

  generateOutputFilename(originalFilename) {
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substring(2, 8);
    const extension = "jpg";
    return `baby-face-${timestamp}-${randomId}.${extension}`;
  }

  async cleanupOldFiles(maxAgeHours = 24) {
    try {
      const files = await fs.promises.readdir(this.uploadDir);
      const now = Date.now();
      const maxAge = maxAgeHours * 60 * 60 * 1000;

      for (const file of files) {
        const filePath = path.join(this.uploadDir, file);
        const stats = await fs.promises.stat(filePath);

        if (now - stats.mtime.getTime() > maxAge) {
          await fs.promises.unlink(filePath);
          console.log(`Cleaned up old file: ${file}`);
        }
      }
    } catch (error) {
      console.error("Error cleaning up files:", error);
    }
  }
}

module.exports = ImageGenerationService;
